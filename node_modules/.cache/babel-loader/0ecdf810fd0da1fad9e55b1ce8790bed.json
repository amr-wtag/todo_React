{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport crossFetch from 'cross-fetch';\nexport class PostgrestBuilder {\n  constructor(builder) {\n    Object.assign(this, builder);\n\n    let _fetch;\n\n    if (builder.fetch) {\n      _fetch = builder.fetch;\n    } else if (typeof fetch === 'undefined') {\n      _fetch = crossFetch;\n    } else {\n      _fetch = fetch;\n    }\n\n    this.fetch = function () {\n      return _fetch(...arguments);\n    };\n\n    this.shouldThrowOnError = builder.shouldThrowOnError || false;\n  }\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n\n\n  throwOnError(throwOnError) {\n    if (throwOnError === null || throwOnError === undefined) {\n      throwOnError = true;\n    }\n\n    this.shouldThrowOnError = throwOnError;\n    return this;\n  }\n\n  then(onfulfilled, onrejected) {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (typeof this.schema === 'undefined') {// skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers['Accept-Profile'] = this.schema;\n    } else {\n      this.headers['Content-Profile'] = this.schema;\n    }\n\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers['Content-Type'] = 'application/json';\n    }\n\n    let res = this.fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal\n    }).then(res => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n\n      let error = null;\n      let data = null;\n      let count = null;\n\n      if (res.ok) {\n        const isReturnMinimal = (_a = this.headers['Prefer']) === null || _a === void 0 ? void 0 : _a.split(',').includes('return=minimal');\n\n        if (this.method !== 'HEAD' && !isReturnMinimal) {\n          const text = yield res.text();\n\n          if (!text) {// discard `text`\n          } else if (this.headers['Accept'] === 'text/csv') {\n            data = text;\n          } else {\n            data = JSON.parse(text);\n          }\n        }\n\n        const countHeader = (_b = this.headers['Prefer']) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);\n        const contentRange = (_c = res.headers.get('content-range')) === null || _c === void 0 ? void 0 : _c.split('/');\n\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1]);\n        }\n      } else {\n        const body = yield res.text();\n\n        try {\n          error = JSON.parse(body);\n        } catch (_d) {\n          error = {\n            message: body\n          };\n        }\n\n        if (error && this.shouldThrowOnError) {\n          throw error;\n        }\n      }\n\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status: res.status,\n        statusText: res.statusText,\n        body: data\n      };\n      return postgrestResponse;\n    }));\n\n    if (!this.shouldThrowOnError) {\n      res = res.catch(fetchError => ({\n        error: {\n          message: `FetchError: ${fetchError.message}`,\n          details: '',\n          hint: '',\n          code: fetchError.code || ''\n        },\n        data: null,\n        body: null,\n        count: null,\n        status: 400,\n        statusText: 'Bad Request'\n      }));\n    }\n\n    return res.then(onfulfilled, onrejected);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["crossFetch","PostgrestBuilder","constructor","builder","Object","assign","_fetch","fetch","shouldThrowOnError","throwOnError","undefined","then","onfulfilled","onrejected","schema","includes","method","headers","res","url","toString","body","JSON","stringify","signal","__awaiter","error","data","count","ok","isReturnMinimal","_a","split","text","parse","countHeader","_b","match","contentRange","get","_c","length","parseInt","message","postgrestResponse","status","statusText","catch","fetchError","details","hint","code"],"sources":["/Users/mridha/Todo_in_React/todo/node_modules/@supabase/postgrest-js/src/lib/types.ts"],"sourcesContent":["import crossFetch from 'cross-fetch'\n\nexport type Fetch = typeof fetch\n\n/**\n * Error format\n *\n * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n */\nexport type PostgrestError = {\n  message: string\n  details: string\n  hint: string\n  code: string\n}\n\n/**\n * Response format\n *\n * {@link https://github.com/supabase/supabase-js/issues/32}\n */\ninterface PostgrestResponseBase {\n  status: number\n  statusText: string\n}\n\ninterface PostgrestResponseSuccess<T> extends PostgrestResponseBase {\n  error: null\n  data: T[]\n  body: T[]\n  count: number | null\n}\ninterface PostgrestResponseFailure extends PostgrestResponseBase {\n  error: PostgrestError\n  data: null\n  // For backward compatibility: body === data\n  body: null\n  count: null\n}\nexport type PostgrestResponse<T> = PostgrestResponseSuccess<T> | PostgrestResponseFailure\n\ninterface PostgrestSingleResponseSuccess<T> extends PostgrestResponseBase {\n  error: null\n  data: T\n  // For backward compatibility: body === data\n  body: T\n}\nexport type PostgrestSingleResponse<T> =\n  | PostgrestSingleResponseSuccess<T>\n  | PostgrestResponseFailure\nexport type PostgrestMaybeSingleResponse<T> = PostgrestSingleResponse<T | null>\n\nexport abstract class PostgrestBuilder<T> implements PromiseLike<PostgrestResponse<T>> {\n  protected method!: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n  protected url!: URL\n  protected headers!: { [key: string]: string }\n  protected schema?: string\n  protected body?: Partial<T> | Partial<T>[]\n  protected shouldThrowOnError: boolean\n  protected signal?: AbortSignal\n  protected fetch: Fetch\n\n  constructor(builder: PostgrestBuilder<T>) {\n    Object.assign(this, builder)\n    let _fetch: Fetch\n    if (builder.fetch) {\n      _fetch = builder.fetch\n    } else if (typeof fetch === 'undefined') {\n      _fetch = crossFetch\n    } else {\n      _fetch = fetch\n    }\n    this.fetch = (...args) => _fetch(...args)\n    this.shouldThrowOnError = builder.shouldThrowOnError || false\n  }\n\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n  throwOnError(throwOnError?: boolean): this {\n    if (throwOnError === null || throwOnError === undefined) {\n      throwOnError = true\n    }\n    this.shouldThrowOnError = throwOnError\n    return this\n  }\n\n  then<TResult1 = PostgrestResponse<T>, TResult2 = never>(\n    onfulfilled?:\n      | ((value: PostgrestResponse<T>) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): PromiseLike<TResult1 | TResult2> {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (typeof this.schema === 'undefined') {\n      // skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers['Accept-Profile'] = this.schema\n    } else {\n      this.headers['Content-Profile'] = this.schema\n    }\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers['Content-Type'] = 'application/json'\n    }\n\n    let res = this.fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal,\n    }).then(async (res) => {\n      let error = null\n      let data = null\n      let count = null\n\n      if (res.ok) {\n        const isReturnMinimal = this.headers['Prefer']?.split(',').includes('return=minimal')\n        if (this.method !== 'HEAD' && !isReturnMinimal) {\n          const text = await res.text()\n          if (!text) {\n            // discard `text`\n          } else if (this.headers['Accept'] === 'text/csv') {\n            data = text\n          } else {\n            data = JSON.parse(text)\n          }\n        }\n\n        const countHeader = this.headers['Prefer']?.match(/count=(exact|planned|estimated)/)\n        const contentRange = res.headers.get('content-range')?.split('/')\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1])\n        }\n      } else {\n        const body = await res.text()\n\n        try {\n          error = JSON.parse(body)\n        } catch {\n          error = {\n            message: body,\n          }\n        }\n\n        if (error && this.shouldThrowOnError) {\n          throw error\n        }\n      }\n\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status: res.status,\n        statusText: res.statusText,\n        body: data,\n      }\n\n      return postgrestResponse\n    })\n    if (!this.shouldThrowOnError) {\n      res = res.catch((fetchError) => ({\n        error: {\n          message: `FetchError: ${fetchError.message}`,\n          details: '',\n          hint: '',\n          code: fetchError.code || '',\n        },\n        data: null,\n        body: null,\n        count: null,\n        status: 400,\n        statusText: 'Bad Request',\n      }))\n    }\n\n    return res.then(onfulfilled, onrejected)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}