{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { get, post, put, remove } from './lib/fetch';\nimport { COOKIE_OPTIONS } from './lib/constants';\nimport { setCookies, getCookieString } from './lib/cookies';\nimport { expiresAt, resolveFetch } from './lib/helpers';\nexport default class GoTrueApi {\n  constructor(_ref) {\n    let {\n      url = '',\n      headers = {},\n      cookieOptions,\n      fetch\n    } = _ref;\n    this.url = url;\n    this.headers = headers;\n    this.cookieOptions = Object.assign(Object.assign({}, COOKIE_OPTIONS), cookieOptions);\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n\n\n  _createRequestHeaders(jwt) {\n    const headers = Object.assign({}, this.headers);\n    headers['Authorization'] = `Bearer ${jwt}`;\n    return headers;\n  }\n\n  cookieName() {\n    var _a;\n\n    return (_a = this.cookieOptions.name) !== null && _a !== void 0 ? _a : '';\n  }\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n\n\n  getUrlForProvider(provider, options) {\n    const urlParams = [`provider=${encodeURIComponent(provider)}`];\n\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n    }\n\n    return `${this.url}/authorize?${urlParams.join('&')}`;\n  }\n  /**\n   * Creates a new user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n\n\n  signUpWithEmail(email, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/signup${queryString}`, {\n          email,\n          password,\n          data: options.data,\n          gotrue_meta_security: {\n            hcaptcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  signInWithEmail(email, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '?grant_type=password';\n\n        if (options.redirectTo) {\n          queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          email,\n          password\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Signs up a new user using their phone number and a password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param data Optional user metadata.\n   */\n\n\n  signUpWithPhone(phone, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/signup`, {\n          phone,\n          password,\n          data: options.data,\n          gotrue_meta_security: {\n            hcaptcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their phone number and password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   */\n\n\n  signInWithPhone(phone, password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const queryString = '?grant_type=password';\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          phone,\n          password\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an OpenID Connect user using their id_token.\n   * @param id_token The IDToken of the user.\n   * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n   * @param provider The provider of the user.\n   * @param client_id The clientID of the user.\n   * @param issuer The issuer of the user.\n   */\n\n\n  signInWithOpenIDConnect(_ref2) {\n    let {\n      id_token,\n      nonce,\n      client_id,\n      issuer,\n      provider\n    } = _ref2;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const queryString = '?grant_type=id_token';\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          id_token,\n          nonce,\n          client_id,\n          issuer,\n          provider\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a magic login link to an email address.\n   * @param email The email address of the user.\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  sendMagicLinkEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n        const data = yield post(this.fetch, `${this.url}/otp${queryString}`, {\n          email,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: {\n            hcaptcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n   * @param phone The user's phone number WITH international prefix\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   */\n\n\n  sendMobileOTP(phone) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/otp`, {\n          phone,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: {\n            hcaptcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n\n\n  signOut(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield post(this.fetch, `${this.url}/logout`, {}, {\n          headers: this._createRequestHeaders(jwt),\n          noResolveJson: true\n        });\n        return {\n          error: null\n        };\n      } catch (e) {\n        return {\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * @deprecated Use `verifyOTP` instead!\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  verifyMobileOTP(phone, token) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/verify`, {\n          phone,\n          token,\n          type: 'sms',\n          redirect_to: options.redirectTo\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Send User supplied Email / Mobile OTP to be verified\n   * @param email The user's email address\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param type verification type that the otp is generated for\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  verifyOTP(_ref3) {\n    let {\n      email,\n      phone,\n      token,\n      type = 'sms'\n    } = _ref3;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/verify`, {\n          email,\n          phone,\n          token,\n          type,\n          redirect_to: options.redirectTo\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata\n   */\n\n\n  inviteUserByEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/invite${queryString}`, {\n          email,\n          data: options.data\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a reset request to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  resetPasswordForEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/recover${queryString}`, {\n          email,\n          gotrue_meta_security: {\n            hcaptcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n\n\n  refreshAccessToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/token?grant_type=refresh_token`, {\n          refresh_token: refreshToken\n        }, {\n          headers: this.headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Set/delete the auth cookie based on the AuthChangeEvent.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   * @param req The request object.\n   * @param res The response object.\n   */\n\n\n  setAuthCookie(req, res) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST');\n      res.status(405).end('Method Not Allowed');\n    }\n\n    const {\n      event,\n      session\n    } = req.body;\n    if (!event) throw new Error('Auth event missing!');\n\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!');\n      setCookies(req, res, [{\n        key: 'access-token',\n        value: session.access_token\n      }, {\n        key: 'refresh-token',\n        value: session.refresh_token\n      }].map(token => {\n        var _a;\n\n        return {\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite\n        };\n      }));\n    }\n\n    if (event === 'SIGNED_OUT') {\n      setCookies(req, res, ['access-token', 'refresh-token'].map(key => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1\n      })));\n    }\n\n    res.status(200).json({});\n  }\n  /**\n   * Deletes the Auth Cookies and redirects to the\n   * @param req The request object.\n   * @param res The response object.\n   * @param options Optionally specify a `redirectTo` URL in the options.\n   */\n\n\n  deleteAuthCookie(req, res, _ref4) {\n    let {\n      redirectTo = '/'\n    } = _ref4;\n    setCookies(req, res, ['access-token', 'refresh-token'].map(key => ({\n      name: `${this.cookieName()}-${key}`,\n      value: '',\n      maxAge: -1\n    })));\n    return res.redirect(307, redirectTo);\n  }\n  /**\n   * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n   * @param req The request object.\n   * @param res The response object.\n   * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n   */\n\n\n  getAuthCookieString(req, res) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST');\n      res.status(405).end('Method Not Allowed');\n    }\n\n    const {\n      event,\n      session\n    } = req.body;\n    if (!event) throw new Error('Auth event missing!');\n\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!');\n      return getCookieString(req, res, [{\n        key: 'access-token',\n        value: session.access_token\n      }, {\n        key: 'refresh-token',\n        value: session.refresh_token\n      }].map(token => {\n        var _a;\n\n        return {\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite\n        };\n      }));\n    }\n\n    if (event === 'SIGNED_OUT') {\n      return getCookieString(req, res, ['access-token', 'refresh-token'].map(key => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1\n      })));\n    }\n\n    return res.getHeader('Set-Cookie');\n  }\n  /**\n   * Generates links to be sent via email or other.\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   * @param email The user's email.\n   * @param password User password. For signup only.\n   * @param data Optional user metadata. For signup only.\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   */\n\n\n  generateLink(type, email) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/generate_link`, {\n          type,\n          email,\n          password: options.password,\n          data: options.data,\n          redirect_to: options.redirectTo\n        }, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  } // User Admin API\n\n  /**\n   * Creates a new user.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param attributes The data you want to create the user with.\n   */\n\n\n  createUser(attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/users`, attributes, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  listUsers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/admin/users`, {\n          headers: this.headers\n        });\n        return {\n          data: data.users,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  getUserById(uid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/admin/users/${uid}`, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get user by reading the cookie from the request.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n\n\n  getUserByCookie(req, res) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!req.cookies) {\n          throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');\n        }\n\n        const access_token = req.cookies[`${this.cookieName()}-access-token`];\n        const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`];\n\n        if (!access_token) {\n          throw new Error('No cookie found!');\n        }\n\n        const {\n          user,\n          error: getUserError\n        } = yield this.getUser(access_token);\n\n        if (getUserError) {\n          if (!refresh_token) throw new Error('No refresh_token cookie found!');\n          if (!res) throw new Error('You need to pass the res object to automatically refresh the session!');\n          const {\n            data,\n            error\n          } = yield this.refreshAccessToken(refresh_token);\n\n          if (error) {\n            throw error;\n          } else if (data) {\n            setCookies(req, res, [{\n              key: 'access-token',\n              value: data.access_token\n            }, {\n              key: 'refresh-token',\n              value: data.refresh_token\n            }].map(token => {\n              var _a;\n\n              return {\n                name: `${this.cookieName()}-${token.key}`,\n                value: token.value,\n                domain: this.cookieOptions.domain,\n                maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                path: this.cookieOptions.path,\n                sameSite: this.cookieOptions.sameSite\n              };\n            }));\n            return {\n              token: data.access_token,\n              user: data.user,\n              data: data.user,\n              error: null\n            };\n          }\n        }\n\n        return {\n          token: access_token,\n          user: user,\n          data: user,\n          error: null\n        };\n      } catch (e) {\n        return {\n          token: null,\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  updateUserById(uid, attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this; //\n\n        const data = yield put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param uid The user uid you want to remove.\n   */\n\n\n  deleteUser(uid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield remove(this.fetch, `${this.url}/admin/users/${uid}`, {}, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Gets the current user details.\n   *\n   * This method is called by the GoTrueClient `update` where\n   * the jwt is set to this.currentSession.access_token\n   * and therefore, acts like getting the currently authenticated used\n   *\n   * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n   */\n\n\n  getUser(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/user`, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates the user data.\n   * @param jwt A valid, logged-in JWT.\n   * @param attributes The data you want to update.\n   */\n\n\n  updateUser(jwt, attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield put(this.fetch, `${this.url}/user`, attributes, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["get","post","put","remove","COOKIE_OPTIONS","setCookies","getCookieString","expiresAt","resolveFetch","GoTrueApi","constructor","url","headers","cookieOptions","fetch","Object","_createRequestHeaders","jwt","cookieName","name","_a","getUrlForProvider","provider","options","urlParams","encodeURIComponent","redirectTo","push","scopes","join","signUpWithEmail","email","password","queryString","data","gotrue_meta_security","hcaptcha_token","captchaToken","session","expires_in","expires_at","error","e","signInWithEmail","signUpWithPhone","phone","signInWithPhone","signInWithOpenIDConnect","id_token","nonce","client_id","issuer","sendMagicLinkEmail","shouldCreateUser","create_user","sendMobileOTP","signOut","noResolveJson","verifyMobileOTP","token","type","redirect_to","verifyOTP","inviteUserByEmail","resetPasswordForEmail","refreshAccessToken","refreshToken","refresh_token","setAuthCookie","req","res","method","setHeader","status","end","event","body","Error","key","value","access_token","map","domain","maxAge","lifetime","path","sameSite","json","deleteAuthCookie","redirect","getAuthCookieString","getHeader","generateLink","createUser","attributes","user","listUsers","users","getUserById","uid","getUserByCookie","cookies","getUserError","getUser","updateUserById","deleteUser","updateUser"],"sources":["/Users/mridha/Todo_in_React/todo/node_modules/@supabase/gotrue-js/src/GoTrueApi.ts"],"sourcesContent":["import { Fetch, get, post, put, remove } from './lib/fetch'\nimport {\n  Session,\n  Provider,\n  AdminUserAttributes,\n  UserAttributes,\n  CookieOptions,\n  User,\n  OpenIDConnectCredentials,\n  VerifyOTPParams,\n} from './lib/types'\nimport { COOKIE_OPTIONS } from './lib/constants'\nimport { setCookies, getCookieString } from './lib/cookies'\nimport { expiresAt, resolveFetch } from './lib/helpers'\n\nimport type { ApiError } from './lib/types'\nexport default class GoTrueApi {\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected cookieOptions: CookieOptions\n  protected fetch: Fetch\n\n  constructor({\n    url = '',\n    headers = {},\n    cookieOptions,\n    fetch,\n  }: {\n    url: string\n    headers?: {\n      [key: string]: string\n    }\n    cookieOptions?: CookieOptions\n    fetch?: Fetch\n  }) {\n    this.url = url\n    this.headers = headers\n    this.cookieOptions = { ...COOKIE_OPTIONS, ...cookieOptions }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n  private _createRequestHeaders(jwt: string) {\n    const headers = { ...this.headers }\n    headers['Authorization'] = `Bearer ${jwt}`\n    return headers\n  }\n\n  private cookieName() {\n    return this.cookieOptions.name ?? ''\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  getUrlForProvider(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    return `${this.url}/authorize?${urlParams.join('&')}`\n  }\n\n  /**\n   * Creates a new user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUpWithEmail(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n      data?: object\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/signup${queryString}`,\n        {\n          email,\n          password,\n          data: options.data,\n          gotrue_meta_security: { hcaptcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an existing user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async signInWithEmail(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = '?grant_type=password'\n      if (options.redirectTo) {\n        queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { email, password },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Signs up a new user using their phone number and a password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param data Optional user metadata.\n   */\n  async signUpWithPhone(\n    phone: string,\n    password: string,\n    options: {\n      data?: object\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/signup`,\n        {\n          phone,\n          password,\n          data: options.data,\n          gotrue_meta_security: { hcaptcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an existing user using their phone number and password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   */\n  async signInWithPhone(\n    phone: string,\n    password: string\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const queryString = '?grant_type=password'\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { phone, password },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an OpenID Connect user using their id_token.\n   * @param id_token The IDToken of the user.\n   * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n   * @param provider The provider of the user.\n   * @param client_id The clientID of the user.\n   * @param issuer The issuer of the user.\n   */\n  async signInWithOpenIDConnect({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider,\n  }: OpenIDConnectCredentials): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const queryString = '?grant_type=id_token'\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { id_token, nonce, client_id, issuer, provider },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a magic login link to an email address.\n   * @param email The email address of the user.\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async sendMagicLinkEmail(\n    email: string,\n    options: {\n      shouldCreateUser?: boolean\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n\n      const shouldCreateUser = options.shouldCreateUser ?? true\n      const data = await post(\n        this.fetch,\n        `${this.url}/otp${queryString}`,\n        {\n          email,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: { hcaptcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n   * @param phone The user's phone number WITH international prefix\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   */\n  async sendMobileOTP(\n    phone: string,\n    options: {\n      shouldCreateUser?: boolean\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const shouldCreateUser = options.shouldCreateUser ?? true\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/otp`,\n        {\n          phone,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: { hcaptcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n  async signOut(jwt: string): Promise<{ error: ApiError | null }> {\n    try {\n      await post(\n        this.fetch,\n        `${this.url}/logout`,\n        {},\n        { headers: this._createRequestHeaders(jwt), noResolveJson: true }\n      )\n      return { error: null }\n    } catch (e) {\n      return { error: e as ApiError }\n    }\n  }\n\n  /**\n   * @deprecated Use `verifyOTP` instead!\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyMobileOTP(\n    phone: string,\n    token: string,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/verify`,\n        { phone, token, type: 'sms', redirect_to: options.redirectTo },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Send User supplied Email / Mobile OTP to be verified\n   * @param email The user's email address\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param type verification type that the otp is generated for\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyOTP(\n    { email, phone, token, type = 'sms' }: VerifyOTPParams,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/verify`,\n        { email, phone, token, type, redirect_to: options.redirectTo },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata\n   */\n  async inviteUserByEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      data?: object\n    } = {}\n  ): Promise<{ data: User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/invite${queryString}`,\n        { email, data: options.data },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a reset request to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/recover${queryString}`,\n        { email, gotrue_meta_security: { hcaptcha_token: options.captchaToken } },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  async refreshAccessToken(\n    refreshToken: string\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const data: any = await post(\n        this.fetch,\n        `${this.url}/token?grant_type=refresh_token`,\n        { refresh_token: refreshToken },\n        { headers: this.headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Set/delete the auth cookie based on the AuthChangeEvent.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   * @param req The request object.\n   * @param res The response object.\n   */\n  setAuthCookie(req: any, res: any) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST')\n      res.status(405).end('Method Not Allowed')\n    }\n    const { event, session } = req.body\n\n    if (!event) throw new Error('Auth event missing!')\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!')\n      setCookies(\n        req,\n        res,\n        [\n          { key: 'access-token', value: session.access_token },\n          { key: 'refresh-token', value: session.refresh_token },\n        ].map((token) => ({\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: this.cookieOptions.lifetime ?? 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite,\n        }))\n      )\n    }\n    if (event === 'SIGNED_OUT') {\n      setCookies(\n        req,\n        res,\n        ['access-token', 'refresh-token'].map((key) => ({\n          name: `${this.cookieName()}-${key}`,\n          value: '',\n          maxAge: -1,\n        }))\n      )\n    }\n    res.status(200).json({})\n  }\n\n  /**\n   * Deletes the Auth Cookies and redirects to the\n   * @param req The request object.\n   * @param res The response object.\n   * @param options Optionally specify a `redirectTo` URL in the options.\n   */\n  deleteAuthCookie(req: any, res: any, { redirectTo = '/' }: { redirectTo?: string }) {\n    setCookies(\n      req,\n      res,\n      ['access-token', 'refresh-token'].map((key) => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1,\n      }))\n    )\n    return res.redirect(307, redirectTo)\n  }\n\n  /**\n   * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n   * @param req The request object.\n   * @param res The response object.\n   * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n   */\n  getAuthCookieString(req: any, res: any): string[] {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST')\n      res.status(405).end('Method Not Allowed')\n    }\n    const { event, session } = req.body\n\n    if (!event) throw new Error('Auth event missing!')\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!')\n      return getCookieString(\n        req,\n        res,\n        [\n          { key: 'access-token', value: session.access_token },\n          { key: 'refresh-token', value: session.refresh_token },\n        ].map((token) => ({\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: this.cookieOptions.lifetime ?? 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite,\n        }))\n      )\n    }\n    if (event === 'SIGNED_OUT') {\n      return getCookieString(\n        req,\n        res,\n        ['access-token', 'refresh-token'].map((key) => ({\n          name: `${this.cookieName()}-${key}`,\n          value: '',\n          maxAge: -1,\n        }))\n      )\n    }\n    return res.getHeader('Set-Cookie')\n  }\n\n  /**\n   * Generates links to be sent via email or other.\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   * @param email The user's email.\n   * @param password User password. For signup only.\n   * @param data Optional user metadata. For signup only.\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   */\n  async generateLink(\n    type: 'signup' | 'magiclink' | 'recovery' | 'invite',\n    email: string,\n    options: {\n      password?: string\n      data?: object\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const data: any = await post(\n        this.fetch,\n        `${this.url}/admin/generate_link`,\n        {\n          type,\n          email,\n          password: options.password,\n          data: options.data,\n          redirect_to: options.redirectTo,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  // User Admin API\n\n  /**\n   * Creates a new user.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param attributes The data you want to create the user with.\n   */\n  async createUser(\n    attributes: AdminUserAttributes\n  ): Promise<\n    { user: null; data: null; error: ApiError } | { user: User; data: User; error: null }\n  > {\n    try {\n      const data: any = await post(this.fetch, `${this.url}/admin/users`, attributes, {\n        headers: this.headers,\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async listUsers(): Promise<{ data: null; error: ApiError } | { data: User[]; error: null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/admin/users`, {\n        headers: this.headers,\n      })\n      return { data: data.users, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async getUserById(\n    uid: string\n  ): Promise<{ data: null; error: ApiError } | { data: User; error: null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/admin/users/${uid}`, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get user by reading the cookie from the request.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n  async getUserByCookie(\n    req: any,\n    res?: any\n  ): Promise<{\n    token: string | null\n    user: User | null\n    data: User | null\n    error: ApiError | null\n  }> {\n    try {\n      if (!req.cookies) {\n        throw new Error(\n          'Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!'\n        )\n      }\n\n      const access_token = req.cookies[`${this.cookieName()}-access-token`]\n      const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`]\n\n      if (!access_token) {\n        throw new Error('No cookie found!')\n      }\n\n      const { user, error: getUserError } = await this.getUser(access_token)\n      if (getUserError) {\n        if (!refresh_token) throw new Error('No refresh_token cookie found!')\n        if (!res)\n          throw new Error('You need to pass the res object to automatically refresh the session!')\n        const { data, error } = await this.refreshAccessToken(refresh_token)\n        if (error) {\n          throw error\n        } else if (data) {\n          setCookies(\n            req,\n            res,\n            [\n              { key: 'access-token', value: data.access_token },\n              { key: 'refresh-token', value: data.refresh_token! },\n            ].map((token) => ({\n              name: `${this.cookieName()}-${token.key}`,\n              value: token.value,\n              domain: this.cookieOptions.domain,\n              maxAge: this.cookieOptions.lifetime ?? 0,\n              path: this.cookieOptions.path,\n              sameSite: this.cookieOptions.sameSite,\n            }))\n          )\n          return { token: data.access_token, user: data.user, data: data.user, error: null }\n        }\n      }\n      return { token: access_token, user: user, data: user, error: null }\n    } catch (e) {\n      return { token: null, user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async updateUserById(\n    uid: string,\n    attributes: AdminUserAttributes\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      this //\n      const data: any = await put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n        headers: this.headers,\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param uid The user uid you want to remove.\n   */\n  async deleteUser(\n    uid: string\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await remove(\n        this.fetch,\n        `${this.url}/admin/users/${uid}`,\n        {},\n        {\n          headers: this.headers,\n        }\n      )\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Gets the current user details.\n   *\n   * This method is called by the GoTrueClient `update` where\n   * the jwt is set to this.currentSession.access_token\n   * and therefore, acts like getting the currently authenticated used\n   *\n   * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n   */\n  async getUser(\n    jwt: string\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/user`, {\n        headers: this._createRequestHeaders(jwt),\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates the user data.\n   * @param jwt A valid, logged-in JWT.\n   * @param attributes The data you want to update.\n   */\n  async updateUser(\n    jwt: string,\n    attributes: UserAttributes\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await put(this.fetch, `${this.url}/user`, attributes, {\n        headers: this._createRequestHeaders(jwt),\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}