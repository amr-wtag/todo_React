{"ast":null,"code":"import { DEFAULT_TIMEOUT } from '../lib/constants';\nimport RealtimeSubscription from '../RealtimeSubscription';\nexport default class Push {\n  /**\n   * Initializes the Push\n   *\n   * @param channel The Channel\n   * @param event The event, for example `\"phx_join\"`\n   * @param payload The payload, for example `{user_id: 123}`\n   * @param timeout The push timeout in milliseconds\n   */\n  constructor(channel, event) {\n    let payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_TIMEOUT;\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload;\n    this.timeout = timeout;\n    this.sent = false;\n    this.timeoutTimer = undefined;\n    this.ref = '';\n    this.receivedResp = null;\n    this.recHooks = [];\n    this.refEvent = null;\n  }\n\n  resend(timeout) {\n    this.timeout = timeout;\n\n    this._cancelRefEvent();\n\n    this.ref = '';\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n    this.send();\n  }\n\n  send() {\n    if (this._hasReceived('timeout')) {\n      return;\n    }\n\n    this.startTimeout();\n    this.sent = true;\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload,\n      ref: this.ref\n    });\n  }\n\n  updatePayload(payload) {\n    this.payload = Object.assign(Object.assign({}, this.payload), payload);\n  }\n\n  receive(status, callback) {\n    var _a;\n\n    if (this._hasReceived(status)) {\n      callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n    }\n\n    this.recHooks.push({\n      status,\n      callback\n    });\n    return this;\n  }\n\n  startTimeout() {\n    if (this.timeoutTimer) {\n      return;\n    }\n\n    this.ref = this.channel.socket.makeRef();\n    this.refEvent = this.channel.replyEventName(this.ref);\n\n    const callback = payload => {\n      this._cancelRefEvent();\n\n      this._cancelTimeout();\n\n      this.receivedResp = payload;\n\n      this._matchReceive(payload);\n    };\n\n    if (this.channel instanceof RealtimeSubscription) {\n      this.channel.on(this.refEvent, callback);\n    } else {\n      this.channel.on(this.refEvent, {}, callback);\n    }\n\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger('timeout', {});\n    }, this.timeout);\n  }\n\n  trigger(status, response) {\n    if (this.refEvent) this.channel.trigger(this.refEvent, {\n      status,\n      response\n    });\n  }\n\n  destroy() {\n    this._cancelRefEvent();\n\n    this._cancelTimeout();\n  }\n\n  _cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n\n    if (this.channel instanceof RealtimeSubscription) {\n      this.channel.off(this.refEvent);\n    } else {\n      this.channel.off(this.refEvent, {});\n    }\n  }\n\n  _cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = undefined;\n  }\n\n  _matchReceive(_ref) {\n    let {\n      status,\n      response\n    } = _ref;\n    this.recHooks.filter(h => h.status === status).forEach(h => h.callback(response));\n  }\n\n  _hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["DEFAULT_TIMEOUT","RealtimeSubscription","Push","constructor","channel","event","payload","timeout","undefined","resend","_cancelRefEvent","ref","refEvent","receivedResp","sent","send","_hasReceived","startTimeout","socket","push","topic","updatePayload","Object","receive","status","callback","_a","response","recHooks","timeoutTimer","makeRef","replyEventName","_cancelTimeout","_matchReceive","on","setTimeout","trigger","destroy","off","clearTimeout","filter","h","forEach"],"sources":["/Users/mridha/Todo_in_React/todo/node_modules/@supabase/realtime-js/src/lib/push.ts"],"sourcesContent":["import { DEFAULT_TIMEOUT } from '../lib/constants'\nimport RealtimeChannel from '../RealtimeChannel'\nimport RealtimeSubscription from '../RealtimeSubscription'\n\nexport default class Push {\n  sent: boolean = false\n  timeoutTimer: number | undefined = undefined\n  ref: string = ''\n  receivedResp: {\n    status: string\n    response: Function\n  } | null = null\n  recHooks: {\n    status: string\n    callback: Function\n  }[] = []\n  refEvent: string | null = null\n\n  /**\n   * Initializes the Push\n   *\n   * @param channel The Channel\n   * @param event The event, for example `\"phx_join\"`\n   * @param payload The payload, for example `{user_id: 123}`\n   * @param timeout The push timeout in milliseconds\n   */\n  constructor(\n    public channel: RealtimeSubscription | RealtimeChannel,\n    public event: string,\n    public payload: { [key: string]: unknown } = {},\n    public timeout: number = DEFAULT_TIMEOUT\n  ) {}\n\n  resend(timeout: number) {\n    this.timeout = timeout\n    this._cancelRefEvent()\n    this.ref = ''\n    this.refEvent = null\n    this.receivedResp = null\n    this.sent = false\n    this.send()\n  }\n\n  send() {\n    if (this._hasReceived('timeout')) {\n      return\n    }\n    this.startTimeout()\n    this.sent = true\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload,\n      ref: this.ref,\n    })\n  }\n\n  updatePayload(payload: { [key: string]: unknown }): void {\n    this.payload = { ...this.payload, ...payload }\n  }\n\n  receive(status: string, callback: Function) {\n    if (this._hasReceived(status)) {\n      callback(this.receivedResp?.response)\n    }\n\n    this.recHooks.push({ status, callback })\n    return this\n  }\n\n  startTimeout() {\n    if (this.timeoutTimer) {\n      return\n    }\n    this.ref = this.channel.socket.makeRef()\n    this.refEvent = this.channel.replyEventName(this.ref)\n\n    const callback = (payload: any) => {\n      this._cancelRefEvent()\n      this._cancelTimeout()\n      this.receivedResp = payload\n      this._matchReceive(payload)\n    }\n\n    if (this.channel instanceof RealtimeSubscription) {\n      this.channel.on(this.refEvent, callback)\n    } else {\n      this.channel.on(this.refEvent, {}, callback)\n    }\n\n    this.timeoutTimer = <any>setTimeout(() => {\n      this.trigger('timeout', {})\n    }, this.timeout)\n  }\n\n  trigger(status: string, response: any) {\n    if (this.refEvent) this.channel.trigger(this.refEvent, { status, response })\n  }\n\n  destroy() {\n    this._cancelRefEvent()\n    this._cancelTimeout()\n  }\n\n  private _cancelRefEvent() {\n    if (!this.refEvent) {\n      return\n    }\n\n    if (this.channel instanceof RealtimeSubscription) {\n      this.channel.off(this.refEvent)\n    } else {\n      this.channel.off(this.refEvent, {})\n    }\n  }\n\n  private _cancelTimeout() {\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = undefined\n  }\n\n  private _matchReceive({\n    status,\n    response,\n  }: {\n    status: string\n    response: Function\n  }) {\n    this.recHooks\n      .filter((h) => h.status === status)\n      .forEach((h) => h.callback(response))\n  }\n\n  private _hasReceived(status: string) {\n    return this.receivedResp && this.receivedResp.status === status\n  }\n}\n"]},"metadata":{},"sourceType":"module"}