{"ast":null,"code":"import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nexport default class RealtimeChannel {\n  constructor(topic) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let socket = arguments.length > 2 ? arguments[2] : undefined;\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = [];\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this.rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError(reason => {\n      if (this.isLeaving() || this.isClosed()) {\n        return;\n      }\n\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', () => {\n      if (!this.isJoining()) {\n        return;\n      }\n\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n    this.presence = new RealtimePresence(this);\n  }\n\n  list() {\n    return this.presence.list();\n  }\n\n  rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n\n    if (this.socket.isConnected()) {\n      this.rejoin();\n    }\n  }\n\n  subscribe() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n    } else {\n      const configs = this.bindings.reduce((acc, binding) => {\n        const {\n          type\n        } = binding;\n\n        if (!['phx_close', 'phx_error', 'phx_reply', 'presence_diff', 'presence_state'].includes(type)) {\n          acc[type] = binding;\n        }\n\n        return acc;\n      }, {});\n\n      if (Object.keys(configs).length) {\n        this.updateJoinPayload({\n          configs\n        });\n      }\n\n      this.joinedOnce = true;\n      this.rejoin(timeout);\n      return this.joinPush;\n    }\n  }\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   */\n\n\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, {}, callback);\n  }\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   */\n\n\n  onError(callback) {\n    this.on(CHANNEL_EVENTS.error, {}, reason => callback(reason));\n  }\n\n  on(type, filter, callback) {\n    this.bindings.push({\n      type,\n      filter: filter !== null && filter !== void 0 ? filter : {},\n      callback: callback !== null && callback !== void 0 ? callback : () => {}\n    });\n  }\n\n  off(type, filter) {\n    this.bindings = this.bindings.filter(bind => {\n      return !(bind.type === type && RealtimeChannel.isEqual(bind.filter, filter));\n    });\n  }\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   */\n\n\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n\n  push(event, payload) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n\n    let pushEvent = new Push(this, event, payload, timeout);\n\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n\n    return pushEvent;\n  }\n\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n\n\n  unsubscribe() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n    this.state = CHANNEL_STATES.leaving;\n\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`);\n      this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef());\n    }; // Destroy joinPush to avoid connection timeouts during unscription phase\n\n\n    this.joinPush.destroy();\n    const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n    leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose());\n    leavePush.send();\n\n    if (!this.canPush()) {\n      leavePush.trigger('ok', {});\n    }\n\n    return leavePush;\n  }\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   */\n\n\n  onMessage(event, payload, ref) {\n    return payload;\n  }\n\n  isMember(topic) {\n    return this.topic === topic;\n  }\n\n  joinRef() {\n    return this.joinPush.ref;\n  }\n\n  rejoin() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n    if (this.isLeaving()) {\n      return;\n    }\n\n    this.socket.leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n\n  trigger(type, payload, ref) {\n    const {\n      close,\n      error,\n      leave,\n      join\n    } = CHANNEL_EVENTS;\n    const events = [close, error, leave, join];\n\n    if (ref && events.indexOf(type) >= 0 && ref !== this.joinRef()) {\n      return;\n    }\n\n    const handledPayload = this.onMessage(type, payload, ref);\n\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n    }\n\n    this.bindings.filter(bind => {\n      var _a, _b;\n\n      return (bind === null || bind === void 0 ? void 0 : bind.type) === type && (((_a = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_b = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _b === void 0 ? void 0 : _b.event) === (payload === null || payload === void 0 ? void 0 : payload.event));\n    }).map(bind => bind.callback(handledPayload, ref));\n  }\n\n  send(payload) {\n    const push = this.push(payload.type, payload);\n    return new Promise((resolve, reject) => {\n      push.receive('ok', () => resolve('ok'));\n      push.receive('timeout', () => reject('timeout'));\n    });\n  }\n\n  replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n\n  static isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false;\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["CHANNEL_EVENTS","CHANNEL_STATES","Push","Timer","RealtimePresence","RealtimeChannel","constructor","topic","params","socket","closed","timeout","joinPush","join","rejoinTimer","rejoinUntilConnected","reconnectAfterMs","receive","state","joined","reset","pushBuffer","forEach","pushEvent","send","onClose","log","joinRef","remove","onError","reason","isLeaving","isClosed","errored","scheduleTimeout","isJoining","on","reply","payload","ref","trigger","replyEventName","presence","list","isConnected","rejoin","subscribe","joinedOnce","configs","bindings","reduce","acc","binding","type","includes","Object","keys","length","updateJoinPayload","callback","close","error","filter","push","off","bind","isEqual","canPush","isJoined","event","startTimeout","updatePayload","unsubscribe","leaving","destroy","leavePush","leave","onMessage","isMember","leaveOpenTopic","joining","resend","events","indexOf","handledPayload","_a","_b","map","Promise","resolve","reject","isErrored","obj1","obj2","k"],"sources":["/Users/mridha/Todo_in_React/todo/node_modules/@supabase/realtime-js/src/RealtimeChannel.ts"],"sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\nimport Push from './lib/push'\nimport RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\nimport RealtimePresence from './RealtimePresence'\n\nexport default class RealtimeChannel {\n  bindings: any[] = []\n  timeout: number\n  state = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n  presence: RealtimePresence\n\n  constructor(\n    public topic: string,\n    public params: { [key: string]: unknown } = {},\n    public socket: RealtimeClient\n  ) {\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this.rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this.onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket.remove(this)\n    })\n    this.onError((reason: string) => {\n      if (this.isLeaving() || this.isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this.isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.on(CHANNEL_EVENTS.reply, {}, (payload: any, ref: string) => {\n      this.trigger(this.replyEventName(ref), payload)\n    })\n    this.presence = new RealtimePresence(this)\n  }\n\n  list() {\n    return this.presence.list()\n  }\n\n  rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this.rejoin()\n    }\n  }\n\n  subscribe(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\n    } else {\n      const configs = this.bindings.reduce(\n        (acc, binding: { [key: string]: any }) => {\n          const { type } = binding\n          if (\n            ![\n              'phx_close',\n              'phx_error',\n              'phx_reply',\n              'presence_diff',\n              'presence_state',\n            ].includes(type)\n          ) {\n            acc[type] = binding\n          }\n          return acc\n        },\n        {}\n      )\n\n      if (Object.keys(configs).length) {\n        this.updateJoinPayload({ configs })\n      }\n\n      this.joinedOnce = true\n      this.rejoin(timeout)\n      return this.joinPush\n    }\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   */\n  onClose(callback: Function) {\n    this.on(CHANNEL_EVENTS.close, {}, callback)\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   */\n  onError(callback: Function) {\n    this.on(CHANNEL_EVENTS.error, {}, (reason: string) => callback(reason))\n  }\n\n  on(type: string, filter?: { [key: string]: string }, callback?: Function) {\n    this.bindings.push({\n      type,\n      filter: filter ?? {},\n      callback: callback ?? (() => {}),\n    })\n  }\n\n  off(type: string, filter: { [key: string]: any }) {\n    this.bindings = this.bindings.filter((bind) => {\n      return !(\n        bind.type === type && RealtimeChannel.isEqual(bind.filter, filter)\n      )\n    })\n  }\n\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   */\n  canPush(): boolean {\n    return this.socket.isConnected() && this.isJoined()\n  }\n\n  push(event: CHANNEL_EVENTS, payload: any, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this.canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  updateJoinPayload(payload: { [key: string]: unknown }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout): Push {\n    this.state = CHANNEL_STATES.leaving\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef())\n    }\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy()\n\n    const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n    leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose())\n    leavePush.send()\n    if (!this.canPush()) {\n      leavePush.trigger('ok', {})\n    }\n\n    return leavePush\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   */\n  onMessage(event: string, payload: any, ref?: string) {\n    return payload\n  }\n\n  isMember(topic: string): boolean {\n    return this.topic === topic\n  }\n\n  joinRef(): string {\n    return this.joinPush.ref\n  }\n\n  rejoin(timeout = this.timeout): void {\n    if (this.isLeaving()) {\n      return\n    }\n    this.socket.leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  trigger(type: string, payload?: any, ref?: string) {\n    const { close, error, leave, join } = CHANNEL_EVENTS\n    const events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(type) >= 0 && ref !== this.joinRef()) {\n      return\n    }\n    const handledPayload = this.onMessage(type, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    this.bindings\n      .filter((bind) => {\n        return (\n          bind?.type === type &&\n          (bind?.filter?.event === '*' ||\n            bind?.filter?.event === payload?.event)\n        )\n      })\n      .map((bind) => bind.callback(handledPayload, ref))\n  }\n\n  send(payload: { type: string; [key: string]: any }) {\n    const push = this.push(payload.type as any, payload)\n\n    return new Promise((resolve, reject) => {\n      push.receive('ok', () => resolve('ok'))\n      push.receive('timeout', () => reject('timeout'))\n    })\n  }\n\n  replyEventName(ref: string): string {\n    return `chan_reply_${ref}`\n  }\n\n  isClosed(): boolean {\n    return this.state === CHANNEL_STATES.closed\n  }\n  isErrored(): boolean {\n    return this.state === CHANNEL_STATES.errored\n  }\n  isJoined(): boolean {\n    return this.state === CHANNEL_STATES.joined\n  }\n  isJoining(): boolean {\n    return this.state === CHANNEL_STATES.joining\n  }\n  isLeaving(): boolean {\n    return this.state === CHANNEL_STATES.leaving\n  }\n\n  private static isEqual(\n    obj1: { [key: string]: string },\n    obj2: { [key: string]: string }\n  ) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n"]},"metadata":{},"sourceType":"module"}